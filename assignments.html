<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="Course homepage for CS 489 Big Data Infrastructure (Winter 2016) at the University of Waterloo">
    <meta name="author" content="Jimmy Lin">
    <title>Big Data Infrastructure</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <link href="css/ie10-viewport-bug-workaround.css" rel="stylesheet">

    <style>
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
      }
    </style>

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>


  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.html">Overview</a></li>
            <li><a href="organization.html">Organization</a></li>
            <li><a href="syllabus.html">Syllabus</a></li>
            <li class="active"><a href="assignments.html">Assignments</a></li>
            <li><a href="software.html">Software</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">


  <div class="page-header">
    <div style="float: right"/><img src="images/waterloo_logo.png"/></div>
    <h1>Assignments <small>CS 489/698 Big Data Infrastructure (Winter 2016)</small></h1>
  </div>

  <div class="subnav">
    <ul class="nav nav-pills">
      <li><a href="#assignment0">0</a></li>
      <li><a href="#assignment1">1</a></li>
      <li><a href="#assignment2">2</a></li>
      <li><a href="#assignment3">3</a></li>
      <li><a href="#assignment4">4</a></li>
      <li><a href="#assignment5">5</a></li>
      <li><a href="#assignment6">6</a></li>
      <li><a href="#assignment7">7</a></li>
    </ul>
  </div>


<section id="assignment0" style="padding-top:35px">
<div>
<h3>Assignment 0: Warmup <small>due 8:30am January 12</small></h3>

<p>The purpose of this assignment is to serve as a simple warmup
exercise and to serve as a practice "dry run" for the submission
procedures of subsequent assignments. You'll have to write a bit of
code but this assignment is mostly about the "mechanics" of setting up
your Hadoop development environment. In addition to running Hadoop
locally in either the Linux student CS environment or on your own
machine, you'll also try running jobs on the Altiscale cluster.</p>

<p>The general setup is as follows:
you will complete your assignments and check everything into a private
GitHub repo. Shortly after the assignment deadline, we'll pull your
repo for grading. Although we will be examining your solutions to
assignment 0, it will not be graded <i>per se</i>.</p>

<p>I'm assuming you already have
a <a href="http://github.com/">GitHub</a> account. If not, create one
as soon as possible. Once you've signed up for an account, go and
<a href="https://education.github.com/discount_requests/new">request
an educational account</a>. This will allow you to create private
repos for free. Please do this as soon as possible since there may be
delays in the request verification process.</p>

<h4 style="padding-top: 10px">Setting up Hadoop and Spark</h4>

<p>Hadoop and Spark are already installed in
the <code>linux.student.cs.uwaterloo.ca</code>
environment (you just need to add some paths).
Alternatively, you may wish to install everything locally
on your own machine. For both, see the <a href="software.html">software page</a> for
more details.</p>

<p>Bespin is a library that contains reference implementations of "big
data" algorithms in MapReduce and Spark. We'll be using it throughout
this course. Go and run
the <a href="https://github.com/lintool/bespin">Word Count in
MapReduce and Spark</a> example as shown in the Bespin README (clone
and build the repo, download the data files, run word count in both
MapReduce in Spark, and verify output). Assuming you are
using <code>linux.student.cs.uwaterloo.ca</code> (or if you have
properly set up your local environment), this task should be as simple
as copying and pasting commands from the Bespin README.</p>

<p>When running Hadoop, you might get the following warning: "Unable
to load native-hadoop library for your platform... using builtin-java
classes where applicable". It's okay: no need to worry.</p>

<h4 style="padding-top: 10px">Time to write some code!</h4>

<p>Create a <b>private</b> repo
called <code>bigdata2016w</code>. I'm assuming that you're
already familiar with Git and GitHub, but just in case, here
is <a href="https://help.github.com/articles/create-a-repo">how you
create a repo on GitHub</a>. For "Who has access to this repository?",
make sure you click "Only the people I specify". If you've
successfully gotten an educational account (per above), you should be
able to create private repos for free. If you're not already familiar
with Git, there are plenty of good tutorials online: do a simple web
search and find one you like.</p>

<p>What you're going to do now is to copy the MapReduce word count
example into you own private repo. Start with
<a href="assignments/pom.xml">this <code>pom.xml</code></a>: copy it
into your <code>bigdata2016w</code> repo. The replace this line in
that file:</p>

<pre>
  &lt;groupId&gt;ca.uwaterloo.cs.bigdata2016w.lintool&lt;/groupId&gt;
</pre>

<p>Instead of <code>lintool</code>, substitute your GitHub
username. You'll be working in your own namespace, so in everything
that follows, substitute your own GitHub username in place
of <code>lintool</code>.</p>

<p>Next, copy:</p>

<ul>
  <li><code>bespin/src/main/java/io/bespin/java/mapreduce/wordcount/WordCount.java</code> over to
  <li><code>bigdata2016w/src/main/java/ca/uwaterloo/cs/bigdata2016w/lintool/assignment0/WordCount.java</code>.
</ul>

<p>Open up this new version of <code>WordCount.java</code> using a
text editor (or your IDE of choice) and change the Java package
to <code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment0</code>.</p>

<p>Now, in the <code>bigdata2016w/</code> base directory, you should
be able to run Maven to build your package:</p>

<pre>
$ mvn clean package
</pre>

<p>Once the build succeeds, you should be able to run the word count
demo program in your own repository:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment0.WordCount \
   -input data/Shakespeare.txt -output wc
</pre>

<p>You should be running this in the Linux student CS environment or
on your own machine. Note that you'll need to copy over the
Shakespeare collection in <code>data/</code>. The output should be
exactly the same as the same program in Bespin, but the difference
here is that the code is now in a repository under your control, in
your own private namespace.<p>

<p>Let's make a simple modification to word count: instead of counting
words, I want to count the occurrences of two-character prefixes of
words, i.e., the first two characters. That is, I want to know how
many words begin with "aa", "ab", "ac", etc., all the way to "zz"
(including special characters, etc.). Create a program
called <code>PrefixCount</code> in the
package <code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment0</code> that does this.</p>

<p>To be clear, the <code>WordCount</code> defines a "word" as
follows:</p>

<pre>
String w = itr.nextToken().toLowerCase().replaceAll("(^[^a-z]+|[^a-z]+$)", "");
</pre>

<p>Simply take whatever <code>w.substring(0, 2)</code> gives you as a
prefix. This means, of course, that you should ignore single
characters.</p>

<p>We should be able to run your program as follows:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment0.PrefixCount \
   -input data/Shakespeare.txt -output cs489-2016w-lintool-a0-shakespeare
</pre>

<p>You shouldn't need to write more than a couple lines of code
(beyond changing class names and other boilerplate). We'll go over the
Hadoop API in more detail in class, but the changes should be
straightforward.</p>

<p>Answer the following questions:</p>

<p><b>Question 1.</b> In the Shakespeare collection, what are the
three most frequent two character prefixes and how many times does
each occur? (Remember when I mentioned "command line"-fu skills in
class? This is where such skills will come in handy...)</p>

<p><b>Question 2.</b> In the Shakespeare collection, how frequent does
the prefix "li" occur?</p>

<p>You can run the above instructions using 
<a href="assignments/check_assignment0_public_linux.py"><code>check_assignment0_public_linux.py</code></a> as follows:</p>

<pre>
$ wget http://lintool.github.io/bigdata-2016w/assignments/check_assignment0_public_linux.py
$ ./check_assignment0_public_linux.py lintool
</pre>

<p>In fact, we'll be using exactly this script to check your
assignment in the Linux Student CS environment. That is, make sure
that your code runs there even if you do development on your own
machine.</p>

<h4 style="padding-top: 10px">Using the Altiscale Cluster</h4>

<p>The <a href="software.html">software page</a> has details on
getting started with the Altiscale cluster. Register your account and
follow instructions to set up ssh into the "workspace".  Make sure
you've properly set up the proxy to view the cluster Resource Manager
(RM) webapp
at <a href="http://rm-ia.s3s.altiscale.com:8088/cluster/"><code>http://rm-ia.s3s.altiscale.com:8088/cluster/</code></a>.
Getting access to the RM webapp is important&mdash;you'll need it to
track your job status and for debugging purposes.</p>

<p>Once you've ssh'ed into the workspace, check out Bespin and run
word count:</p>

<pre>
$ hadoop jar target/bespin-0.1.0-SNAPSHOT.jar io.bespin.java.mapreduce.wordcount.WordCount \
   -input /shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt -output wc-jmr-combiner
</pre>

<p>Note that we're running word count over a larger collection here: a
10% sample of English Wikipedia totaling 1.3 GB (here's a chance to
exercise your newly-acquired HDFS skills to confirm for yourself).</p>

<p><b>Question 3.</b> Were you able to successfully run word count on
the Altiscale cluster and get access to the Resource Manager webapp?
(Yes or No)</p>

<p>Now switch into your own <code>bigdata2016w/</code> repo and run
your prefix count program on the sample Wikipedia data:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment0.PrefixCount \
   -input /shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt -output cs489-2016w-lintool-a0-wiki
</pre>

<p><b>Question 4.</b> In the sample Wikipedia collection, what are the
three most frequent two character prefixes and how many times does
each occur?</p>

<p><b>Question 5.</b> In the sample Wikipedia collection, How frequent
does the prefix "li" occur?</p>

<p>Note that the Altiscale cluster is a shared resource, and how fast
your jobs complete will depend on how busy it is. You're advised to
begin the assignment early as to avoid long job queues. "I wasn't able
to complete the assignment because there were too many jobs running on
the cluster" will not be accepted as an excuse if your assignment is
late.</p>

<p>You can run the above instructions using 
<a href="assignments/check_assignment0_public_altiscale.py"><code>check_assignment0_public_altiscale.py</code></a> as follows:</p>

<pre>
$ wget http://lintool.github.io/bigdata-2016w/assignments/check_assignment0_public_altiscale.py
$ ./check_assignment0_public_altiscale.py lintool
</pre>

<p>In fact, we'll be using exactly this script to check your
assignment on the Altiscale cluster.</p>


<h4 style="padding-top: 10px">Turning in the Assignment</h4>

<p>At this point, you should have a GitHub
repo <code>bigdata2016w/</code> and inside the repo, you should have
the word count program copied over from Bespin and the new prefix count
implementation, along with your <code>pom.xml</code>.  Commit these
files. Next, create a file called <code>assignment0.md</code>
inside <code>bigdata2016w/</code>. In that file, put your answers to
the above questions (1&mdash;5). Use the Markdown annotation format: here's
a <a href="http://daringfireball.net/projects/markdown/basics">simple
guide</a>.</p>

<p><b>Note:</b> there is no need to commit <code>data/</code>
or <code>target/</code> (or any results that you may have generated),
so your repo should be very compact &mdash; it should only have four
files: two Java source files, <code>pom.xml</code>,
and <code>assignment0.md</code>. You can add a <code>.gitignore</code>
file if you wish.</p>

<p>For this and all subsequent assignments, make sure everything is on
the master branch. Push your repo to GitHub. You can verify that it's
there by logging into your GitHub account in a web browser: your
assignment should be viewable in the web interface.</p>

<p>For this (and the following assignments) there are two parts, one
that can be completed locally, and another that requires the Altiscale
cluster. For the first, make sure that your code runs in the Linux
Student CS environment (even if you do development on your own
machine), which is where we will be doing the grading. "But it runs on
my laptop!" will not be accepted as an excuse if we can't get your
code to run.</p>

<p>Almost there! Add the
user <a href="https://github.com/teachtool">teachtool</a> a
collaborator to your repo so that we can access it (under settings in
the main web interface on your repo). Note: do <b>not</b> add my
primary GitHub
account <a href="https://github.com/lintool">lintool</a> as a
collaborator.</p>

<p>Finally, you need to tell us your GitHub account so we can link it
to you. Submit your user
name <a href="http://goo.gl/forms/UBIaZNNzHF">here</a>.</p>

<p>And that's it!</p>

<p>To give you an idea of how we'll be grading this and future
assignments&mdash;we will clone your repo and use the above check
scripts:</p>

<ul>

<li><a href="assignments/check_assignment0_public_linux.py"><code>check_assignment0_public_linux.py</code></a>
in the Linux Student CS environment.</li>

<li><a href="assignments/check_assignment0_public_altiscale.py"><code>check_assignment0_public_altiscale.py</code></a> on the Altiscale cluster.</li>

</ul>

<p>We'll make sure the data files are in the right place, and once the
code completes, we will verify the output. It is highly recommend that
you run these check scripts: if it doesn't work for you, it won't work
for us either.</p>

<p>As mentioned above, one main purpose of this assignment is to
provide a practice "dry run" of how assignments will be submitted in
the future. It is your responsibility to follow these instructions and
learn the process: we will work with you to get the process sorted out
for this assignment, but in subsequent assignments, you may be docked
points for failing to conform to our expectations.</p>

<p style="padding-top: 20px"><a href="#">Back to top</a></p>
</div>
</section>


<section id="assignment1" style="padding-top:35px">
<div>
<h3>Assignment 1: Counting in MapReduce <small>due 8:30am January 19</small></h3>

<p>By now, you should already be familiar with the Hadoop execution
environment (e.g., submitting jobs) and using Maven to organize your
assignments. You will be working in the same repo as before, except
that everything should go into the package namespace
<code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment1</code>
(obviously, replace <code>lintool</code> with your actual GitHub
username.</p>

<p>Note that the point of assignment 0 was to familiarize your with
GitHub and the Hadoop development environment. We will work through
issues with you, but starting this assignment, excuses along the lines
of "I couldn't get my repo set up properly", "I couldn't figure out
how to push my assignment to GitHub", etc. will not be accepted. It is
your responsibility to sort through any mechanics issue you have.</p>

<p>Before staring this assignment, it is <i>highly recommended</i>
that you look at the implementations of bigram relative frequency and
co-occurrence matrix computation
in <a href="http://bespin.io">Bespin</a>.</p>

<p>In this assignment you'll be
computing <a href="http://en.wikipedia.org/wiki/Pointwise_mutual_information">pointwise
mutual information</a>, which is a function of two events <i>x</i>
and <i>y</i>:</p>

<p><img width="200" src="assignments/PMI.png"/></p>

<p>The larger the magnitude of PMI for <i>x</i> and <i>y</i> is,
the more information you know about the probability of seeing <i>y</i>
having just seen <i>x</i> (and vice-versa, since PMI is
symmetrical). If seeing <i>x</i> gives you no information about seeing
<i>y</i>, then <i>x</i> and <i>y</i> are independent and the PMI is
zero.</p>

<p>Write a program (two separate implementations, actually&mdash;more details below)
that computes the PMI of words in the
<code>data/Shakespeare.txt</code> collection that's used in the Bespin
demos and the previous assignment. Your implementation should be in Java. To be more specific, the event
we're after is <i>x</i> occurring on a line in the file (the denominator above) or <i>x</i>
and <i>y</i> co-occurring on a line (the numerator above). That is, if a line contains "A B
C", then the co-occurring pairs are:</p>

<ul>
  <li>(A, B)</li>
  <li>(A, C)</li>
  <li>(B, A)</li>
  <li>(B, C)</li>
  <li>(C, A)</li>
  <li>(C, B)</li>
</ul>

<p>If the line contains "A A B C", the co-occurring pairs are still
the same as above; same if the line contains "A B C A B C"; or any
combinations of A, B, and C in any order.</p>

<p>A few additional important details:</p>

<ul>

<li>To reduce the number of spurious pairs, we are only interested in
pairs of words that co-occur in ten or more lines.</li>

<li>To reduce the computational complexity of the problem, we are only
going to consider up to the first 100 words in each line.</li>

<li>Just so everyone's answer is consistent, please use
log base 10.</li>

</ul>

<p>Use the same definition of "word" as in the word count demo.
Just to make sure we're all on the same page, use this as the
starting point of your mapper:</p>

<pre>
    @Override
    public void map(LongWritable key, Text value, Context context)
        throws IOException, InterruptedException {
      String line = ((Text) value).toString();
      StringTokenizer itr = new StringTokenizer(line);

      int cnt = 0;
      Set<String> set = Sets.newHashSet();
      while (itr.hasMoreTokens()) {
        cnt++;
        String w = itr.nextToken().toLowerCase().replaceAll("(^[^a-z]+|[^a-z]+$)", "");
        if (w.length() == 0) continue;
        set.add(w);
        if (cnt >= 100) break;
      }

      String[] words = new String[set.size()];
      words = set.toArray(words);

      // Your code goes here...
   }
</pre>

<p>You will build two versions of the program (put both in
package <code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment1</code>):</p>

<ol>

  <li>A "pairs" implementation. The implementation must use
  combiners. Name this implementation <code>PairsPMI</code>.</li>

  <li>A "stripes" implementation.  The implementation must use
  combiners. Name this implementation <code>StripesPMI</code>.</li>

</ol>

<p>Since PMI is symmetrical, PMI(x, y) = PMI(y, x). However, it's
actually easier in your implementation to compute both values, so
don't worry about duplicates. Also, use <code>TextOutputFormat</code>
so the results of your program are human readable.</p>

<p>Make sure that the pairs implementation and the stripes
implementation give the same answers!</p>

<p>Answer the following questions:</p>

<p><b>Question 1.</b> (6 points) <i>Briefly</i> describe in prose your solution,
both the pairs and stripes implementation. For example: how many
MapReduce jobs? What are the input records? What are the intermediate
key-value pairs? What are the final output records? A paragraph for
each implementation is about the expected length.</p>

<p><b>Question 2.</b> (2 points) What is the running time of the complete pairs
implementation? What is the running time of the complete stripes
implementation? (Tell me where you ran these experiments,
e.g., <code>linux.student.cs.uwaterloo.ca</code> or your own
laptop.)</p>

<p><b>Question 3.</b> (2 points) Now disable all combiners. What is the running
time of the complete pairs implementation now? What is the running
time of the complete stripes implementation? (Tell me where you ran
these experiments, e.g., <code>linux.student.cs.uwaterloo.ca</code> or
your own laptop.)</p>

<p><b>Question 4.</b> (3 points) How many distinct PMI pairs did you extract?</p>

<p><b>Question 5.</b> (3 points) What's the pair (x, y) (or pairs if there are
ties) with the highest PMI? Write a sentence or two to explain why
such a high PMI.</p>

<p><b>Question 6.</b> (6 points) What are the three words that have the highest
PMI with "tears" and "death"? And what are the PMI values?</p>

<p>Note that you can compute the answer to questions 4&mdash;6 however
you wish: a helper Java program, a Python script, command-line
one-liner, etc.</p>

<h4 style="padding-top: 10px">Running on the Altiscale cluster</h4>

<p>Now, on the Altiscale cluster, run your pairs and stripes
implementation on the sample Wikipedia collection stored on HDFS
at <code>/shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt</code>. Note
that in the Wikipedia collection, each article is on a line, so
we're computing co-occurring words in (the beginning of) the article. Also, the
"first 100 words" restriction will definitely apply here (whereas in
the Shakespeare collection, all the lines contained fewer than 100
words, so it was a no-op).</p>

<p>Make sure your code runs on this larger dataset. Assuming that
there aren't many competing jobs on the cluster, your programs should
not take more than 20 minutes to run. If your job is taking much
longer than that, then please kill it so it doesn't waste resources
and slow other people's jobs down. Obviously, if the cluster is really
busy or if there's a long list of queued jobs, your job will take
longer, so use your judgement here. The only point is: be nice. It's a
shared resource, and let's not let runaway jobs slow everyone
down.</p>

<p>One final detail, set your MapReduce job parameters as follows:</p>

<pre>
job.getConfiguration().setInt("mapred.max.split.size", 1024 * 1024 * 64);
job.getConfiguration().set("mapreduce.map.memory.mb", "3072");
job.getConfiguration().set("mapreduce.map.java.opts", "-Xmx3072m");
job.getConfiguration().set("mapreduce.reduce.memory.mb", "3072");
job.getConfiguration().set("mapreduce.reduce.java.opts", "-Xmx3072m");
</pre>

<p>What the last four options do is fairly obvious. The first sets
the <i>maximum</i> split size to be 64 MB. What effect does that have?
(Hint, consider the physical execution of MapReduce programs we
discussed in class)</p>

<p><b>Question 7.</b> (6 points) In the Wikipedia sample, what are the three
words that have the highest PMI with "waterloo" and "toronto"? And
what are the PMI values?</p>

<p>It's worth noting again: the Altiscale cluster is a shared
resource, and how fast your jobs complete will depend on how busy it
is. You're advised to begin the assignment early as to avoid long job
queues. "I wasn't able to complete the assignment because there were
too many jobs running on the cluster" will not be accepted as an
excuse if your assignment is late.</p>

<h4 style="padding-top: 10px">Turning in the Assignment</h4>

<p>Please follow these instructions carefully!</p>

<p>Make sure your repo has the following items:</p>

<ul>

<li>Similar to assignment 0, the answers to the questions go
in <code>bigdata2016w/assignment1.md</code>.</li>

<li>The pairs and stripes implementation should be in
package <code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment1</code>.</li>

</ul>

<p>When grading, we will pull your repo and build your code:<p>

<pre>
$ mvn clean package
</pre>

<p>Your code should build successfully. We are then going to check
your code (both the pairs and stripes implementations).</p>

<p>We're going to run your code on the Linux student CS environment as
follows (we will make sure the collection is there):</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment1.PairsPMI \
   -input data/Shakespeare.txt -output cs489-2016w-lintool-a1-shakespeare-pairs -reducers 5

$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment1.StripesPMI \
   -input data/Shakespeare.txt -output cs489-2016w-lintool-a1-shakespeare-stripes -reducers 5
</pre>

<p>Make sure that your code runs in the Linux Student CS environment
(even if you do development on your own machine), which is where we
will be doing the grading. "But it runs on my laptop!" will not be
accepted as an excuse if we can't get your code to run.</p>

<p>You can run the above instructions using 
<a href="assignments/check_assignment1_public_linux.py"><code>check_assignment1_public_linux.py</code></a>.</p>

<p>We're going to run your code on the Altiscale cluster as
follows:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment1.PairsPMI \
   -input /shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt -output cs489-2016w-lintool-a1-wiki-pairs -reducers 5

$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment1.StripesPMI \
   -input /shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt -output cs489-2016w-lintool-a1-wiki-stripes -reducers 5
</pre>

<p>You can run the above instructions using 
<a href="assignments/check_assignment1_public_altiscale.py"><code>check_assignment1_public_altiscale.py</code></a>.</p>

<p><b>Important:</b> Make sure that your code accepts the command-line
parameters above! That is, make sure the check scripts work!<p>

<p>When you've done everything, commit to your repo and remember to
push back to origin. You should be able to see your edits in the web
interface. Before you consider the assignment "complete", verify
everything above works by performing a clean clone of your repo and
going through the steps above.</p>

<p>That's it! There's no need to send us anything&mdash;we already know
your username from the first assignment. Note that everything should
be committed and pushed to origin before the deadline.</p>

<h4 style="padding-top: 10px">Hints</h4>

<ul>
  <li>Did you take a look at the implementations of bigram relative
  frequency and co-occurrence matrix computation
  in <a href="http://bespin.io">Bespin</a>?</li>

  <li>Your solution will likely require more than one MapReduce job.</li>

  <li>You may have to load in "side data"?</li>

  <li>My <a href="https://github.com/lintool/tools/tree/master/lintools-datatypes/">lintools-datatypes
  package</a> has <code>Writable</code> datatypes that you might find
  useful. (Feel free to use, but assignment can be completed
  without it.)</li>

</ul>

<h4 style="padding-top: 10px">Grading</h4>

<p>This assignment is worth a total of 50 points, broken down as
follows:</p>

<ul>

  <li>The questions above are worth a total of 28 points.</li>

  <li>Getting your code to compile and successfully run is worth
  another 16 points (4 points each for the pairs and stripes
  implementation in the Linux student CS environment and on
  Altiscale). We will make a minimal effort to fix <i>trivial</i>
  issues with your code (e.g., a typo)&mdash;and deduct
  points&mdash;but <b>will not</b> spend time debugging your code. It
  is your responsibility to make sure your code runs: we have taken
  care to specify exactly how we will run your code&mdash;if anything
  is unclear, it is your responsibility to seek clarification.  In
  order to get a perfect score of 16 for this portion of the grade, we
  should be able to run the two public check
  scripts: <a href="assignments/check_assignment1_public_linux.py"><code>check_assignment1_public_linux.py</code></a>
  (on Linux Student CS)
  an <a href="assignments/check_assignment1_public_altiscale.py"><code>check_assignment1_public_altiscale.py</code></a>
  (on Altiscale cluster) successfully without any errors.</li>

  <li>Another 6 points is allotted to us verifying the output of your
  program in ways that we will not tell you. We're giving you the
  "public" versions of the check scripts; we'll run a "private"
  version to examine your output further (i.e., think blind test
  cases).</li>

</ul>

<p style="padding-top: 20px"><a href="#">Back to top</a></p>
</div>
</section>


<section id="assignment2" style="padding-top:35px">
<div>
<h3>Assignment 2: Counting in Spark <small>due 8:30am January 26</small></h3>

<p>In this assignment you will "port" the MapReduce implementations of
the bigram frequency count program
from <a href="http://bespin.io">Bespin</a> over to Spark (in
Scala). Your starting points
are <code>ComputeBigramRelativeFrequencyPairs</code>
and <code>ComputeBigramRelativeFrequencyStripes</code> in
package <code>io.bespin.java.mapreduce.bigram</code> (in Java).
You are welcome to build on the <code>BigramCount</code> (Scala)
implementation <a href="https://github.com/lintool/bespin/blob/master/src/main/scala/io/bespin/scala/spark/bigram/BigramCount.scala">here</a>
for tokenization and "boilerplate" code like command-line argument
parsing. To be consistent in tokenization, you should copy over
the <code>Tokenizer</code> trait
<a href="https://github.com/lintool/bespin/blob/master/src/main/scala/io/bespin/scala/util/Tokenizer.scala">here</a>. You'll
also need to grab missing Maven dependencies
from <a href="https://github.com/lintool/bespin/blob/master/pom.xml">here</a>.</p>

<p>Put your code in the
package <code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment2</code>. Since
you'll be writing Scala code, your source files should go
into <code>src/main/scala/ca/uwaterloo/cs/bigdata2016w/lintool/assignment2/</code>. Note
that the repository is designed so that Scala/Spark code will also
compile with the same Maven build command:</p>

<pre>
$ mvn clean package
</pre>

<p>Following the Java implementations, you will write both a "pairs"
and a "stripes" implementation in Spark. Not that although Spark has a
different API than MapReduce, the algorithmic concepts are still very
much applicable. Your pairs and stripes implementation should follow
the same logic as in the MapReduce implementations. In particular,
your program should only take one pass through the input data.</p>

<p>Make sure your implementation runs in the Linux student CS
environment on the Shakespeare collection and also on sample
Wikipedia
file <code>/shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt</code>
on HDFS in the Altiscale cluster. Note that submitting Spark jobs on
the Altiscale cluster requires a rather arcane command-line
invocation&nbsp;see the <a href="software.html">software page</a> for
more details.</p>

<p>You can verify the correctness of your algoritm by comparing the
output of the MapReduce implementation with your Spark
implementation. The output should be the same.</p>

<p>Clarification on terminology: informally, we often refer to
"mappers" and "reducers" in the context of Spark. That's a shorthand
way of saying map-like transformations
(<code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>mapPartitions</code>,
etc.) and reduce-like transformations
(e.g., <code>reduceByKey</code>, <code>groupByKey</code>, <code>aggregateByKey</code>,
etc.). Hopefully it's clear from lecture that while Spark represents a
generalization of MapReduce, the notions of per-record processing
(i.e., map-like transformation) and grouping/shuffling (i.e.,
reduce-like transformations) are shared across both frameworks.</p>

<h4 style="padding-top: 10px">Turning in the Assignment</h4>

<p>Please follow these instructions carefully!</p>

<p>The pairs and stripes implementation should be in
package <code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment2</code>;
your Scala code should be
in <code>src/main/scala/ca/uwaterloo/cs/bigdata2016w/lintool/assignment2/</code>.
There are no questions to answer in this assignment unless there is
something you would like to communicate with us, and if so, put it
in <code>assignment2.md</code>.</p>

<p>When grading, we will pull your repo and build your code:<p>

<pre>
$ mvn clean package
</pre>

<p>Your code should build successfully. We are then going to check
your code (both the pairs and stripes implementations).</p>

<p>We're going to run your code on the Linux student CS environment as
follows (we will make sure the collection is there):</p>

<pre>
$ spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment2.ComputeBigramRelativeFrequencyPairs \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input data/Shakespeare.txt --output cs489-2016w-lintool-a2-shakespeare-pairs --reducers 5

$ spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment2.ComputeBigramRelativeFrequencyStripes \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input data/Shakespeare.txt --output cs489-2016w-lintool-a2-shakespeare-stripes --reducers 5
</pre>

<p>Make sure that your code runs in the Linux Student CS environment
(even if you do development on your own machine), which is where we
will be doing the grading. "But it runs on my laptop!" will not be
accepted as an excuse if we can't get your code to run.</p>

<p>We're going to run your code on the Altiscale cluster as follows
(note we add <code>--num-executors 10</code> to specify the number of
executors; also note that we use the <code>my-spark-submit</code>
launch script&mdash;see the <a href="software.html">software</a>
page for details):</p>

<pre>
$ my-spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment2.ComputeBigramRelativeFrequencyPairs --num-executors 10 \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input /shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt \
   --output cs489-2016w-lintool-a2-wiki-pairs --reducers 10

$ my-spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment2.ComputeBigramRelativeFrequencyStripes --num-executors 10 \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input /shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt \
   --output cs489-2016w-lintool-a2-wiki-stripes --reducers 10
</pre>

<p><b>Important:</b> Make sure that your code accepts the command-line
parameters above!<p>

<p>Brief explanation about the relationship
between <code>--num-executors</code>
and <code>--reducers</code>. The <code>--num-executors</code> flag
specifies the number of Spark workers that you allocate for this
particular job. The <code>--reducers</code> flag is the amount of
parallelism that you set in your program in the reduce
stage. If <code>--num-executors</code> is larger
than <code>--reducers</code>, some of the workers will be sitting
idle, since you've allocated more workers for the job than the
parallelism you've specified in your
program. If <code>--reducers</code> is larger
than <code>--num-executors</code>, then your reduce tasks will queue
up at the workers, i.e., a worker will be assigned more than one
reduce task. In the above example we set the two equal.</p>

<p>Note that the setting of these two parameters should not affect the
correctness of your program. The setting of ten above is a reasonable
middle ground between having your jobs finish in a reasonable amount
of time and not monopolizing cluster resources.</p>

<p>A related but still orthogonal concept is partitions. Partitions
describes the physical division of records across workers during
execution. When reading from HDFS, the number of HDFS blocks
determines the number of partitions in your RDD. When you apply a
reduce-like transformation, you can optionally specify the number of
partitions (or Spark applies a default) &mdash; in this case, the
number of partitions is equal to the number of reducers.</p>

<p>When you've done everything, commit to your repo and remember to
push back to origin. You should be able to see your edits in the web
interface. Before you consider the assignment "complete", I would
recommend that you verify everything above works by performing a clean
clone of your repo and going through the steps above.</p>

<p>That's it!</p>

<h4 style="padding-top: 10px">Grading</h4>

<p>This assignment is worth a total of 20 points, broken down as
follows:</p>

<ul>
  <li>The pairs implementation running locally is worth 6 points; the stripes implementation running locally is worth another 6 points.</li>
  <li>The pairs implementation running on Altiscale is worth 4 points; the stripes implementation running on Altiscale is worth another 4 points.</li>
</ul>

<p style="padding-top: 20px"><a href="#">Back to top</a></p>
</div>
</section>


<section id="assignment3" style="padding-top:35px">
<div>
<h3>Assignment 3: Inverted Indexing <small>due 8:30am February 2</small></h3>

<p>This assignment is to be completed in MapReduce in Java. You will
be working in the same repo as before, except that everything should
go into the package namespace
<code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment3</code>
(obviously, replace <code>lintool</code> with your actual GitHub
username.</p>

<p>Look at the inverted indexing and boolean retrieval implementation
in <a href="http://bespin.io">Bespin</a>. Make sure you understand the
code. Starting from the inverted indexing
baseline <code>BuildInvertedIndex</code>, modify the indexer code in
the following ways:</p>

<p><b>1. Index Compression.</b> The index should be compressed using
<code>VInts</code>:
see <code>org.apache.hadoop.io.WritableUtils</code>. You should also
use gap-compression techniques as appropriate.</p>

<p><b>2. Buffering postings.</b> The baseline indexer implementation
currently buffers and sorts postings in the reducer, which as we
discussed in class is not a scalable solution. Address this
scalability bottleneck using techniques we discussed in class and in
the textbook.</p>

<p><b>3. Term partitioning.</b> The baseline indexer implementation
currently uses only one reducer and therefore all postings lists are
shuffled to the same node and written to HDFS in a single
partition. Change this so we can specify the number of reducers
(hence, partitions) as a command-line argument. This is, of course,
easy to do, but we need to make sure that the searcher understands
this partitioning also.</p>

<p><b>Note:</b> The major scalability issue is
buffering <i>uncompressed</i> postings in memory. In your solution,
you'll still end up buffering each postings list, but
in <i>compressed</i> form (raw bytes, no additional object
overhead). This is fine because if you use the right compression
technique, the postings lists are quite small. As a data point, on a
collection of 50 million web pages, 2GB heap is more than enough for a
full <i>positional</i> index (and in this assignment you're not asked
to store positional information in your postings).</p>

<p>To go into a bit more detail: in the reference implementation, the
final key type is <code>PairOfWritables&lt;IntWritable,
ArrayListWritable&lt;PairOfInts&gt;&gt;</code>. The most obvious idea
is to change that into something
like <code>PairOfWritables&lt;VIntWritable,
ArrayListWritable&lt;PairOfVInts&gt;&gt;</code>. This does not work!
The reason is that you will still be materializing each posting, i.e.,
all <code>PairOfVInts</code> objects in memory. This translates into a
Java object for every posting, which is wasteful in terms of memory
usage and will exhaust memory pretty quickly as you scale. In other
words, you're <i>still</i> buffering objects&mdash;just inside
the <code>ArrayListWritable</code>.

<p>This new indexer should be
named <code>BuildInvertedIndexCompressed</code>. This new class should
be in the
package <code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment3</code>. Make
sure it works on the Shakespeare collection.</p>

<p>Modify <code>BooleanRetrieval</code> so that it works with the new
compressed indexes. Name this new
class <code>BooleanRetrievalCompressed</code>. This new class should
be in the same package as above and give the same
output as the old version.</p>

<p>Use <code>BuildInvertedIndex</code>
and <code>BooleanRetrieval</code> from Bespin as your starting
points. That is, copy over into your repo, rename, and begin your
assignment from there. Don't unnecessarily change code not directly
related to points #1-#3 above. In particular, <b>do not</b> change how
the documents are tokenized, etc. in <code>BuildInvertedIndex</code>
(otherwise there's no good way to check for the correctness of your
algorithm). Also, <b>do not</b> change the <code>fetchLine</code>
method in <code>BooleanRetrieval</code> so that everyone's output
looks the same.</p>

<p>In more detail, make sure that you can build the inverted index
with the following command (make sure your implementation runs in the
Linux student CS environment, as that is where we will be doing the
grading):</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment3.BuildInvertedIndexCompressed \
   -input data/Shakespeare.txt -output cs489-2016w-lintool-a3-index-shakespeare -reducers 4
</pre>

<p>We should be able to control the number of partitions (#3 above)
with the <code>-reducers</code> option. That is, the code should give
the correct results no matter what we set the value to.</p>

<p>Once we build the index, we should then be able to run a boolean
query as follows (in exactly the same manner
as <code>BooleanRetrieval</code> in Bespin</a>):</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment3.BooleanRetrievalCompressed \
   -index cs489-2016w-lintool-a3-index-shakespeare -collection data/Shakespeare.txt \
   -query "outrageous fortune AND"

$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment3.BooleanRetrievalCompressed \
   -index cs489-2016w-lintool-a3-index-shakespeare -collection data/Shakespeare.txt \
   -query "white red OR rose AND pluck AND"
</pre>

<p>Of course, we will try your program with additional queries to
verify its correctness.</p>

<p>Answer the following question:</p>

<p><b>Question 1.</b> What is the size of your compressed
index for Shakespeare collection? Just so we're using the same units,
report the output of <code>du -h</code>.</p>

<h4 style="padding-top: 10px">Running on the Altiscale cluster</h4>

<p>Now let's try running your implementation on the Altiscale cluster,
on the sample Wikipedia
file <code>/shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt</code>
on HDFS:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment3.BuildInvertedIndexCompressed \
   -input /shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt \
   -output cs489-2016w-lintool-a3-index-wiki -reducers 4
</pre>

<p>And let's try running a query:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment3.BooleanRetrievalCompressed \
   -index cs489-2016w-lintool-a3-index-wiki \
   -collection /shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt \
   -query "waterloo stanford OR cheriton AND"

$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment3.BooleanRetrievalCompressed \
   -index cs489-2016w-lintool-a3-index-wiki \
   -collection /shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt \
   -query "internet startup AND canada AND ontario AND"
</pre>

<p>Answer the following questions:</p>

<p><b>Question 2.</b> What is the size of your compressed
index for the sample Wikipedia collection? Just so we're using the
same units, report the output of <code>hadoop fs -du -h</code>.</p>

<p><b>Question 3.</b> What are the Wikipedia articles (just the
article titles) retrieved in response to the query <code>"waterloo
stanford OR cheriton AND"</code>?</p>

<p><b>Question 4.</b> What are the Wikipedia articles (just
the article titles) retrieved in response to the query <code>"internet
startup AND canada AND ontario AND"</code>?</p>

<h4 style="padding-top: 10px">Turning in the Assignment</h4>

<p>Please follow these instructions carefully!</p>

<p>Make sure your repo has the following items:</p>

<ul>

<li>Similar to the previous assignments, the answers to the questions go
in <code>bigdata2016w/assignment3.md</code>.</li>

<li>The implementations should be in
package <code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment3</code>.</li>

</ul>

<p>Make sure your implementation runs in the Linux student CS
environment on the Shakespeare collection and also on sample Wikipedia
file <code>/shared/cs489/data/enwiki-20151201-pages-articles-0.1sample.txt</code>
on HDFS in the Altiscale cluster, per above.</p>

<p>Specifically, we will clone your repo and use the below check
scripts:</p>

<ul>

<li><a href="assignments/check_assignment3_public_linux.py"><code>check_assignment3_public_linux.py</code></a>
in the Linux Student CS environment.</li>

<li><a href="assignments/check_assignment3_public_altiscale.py"><code>check_assignment3_public_altiscale.py</code></a> on the Altiscale cluster.</li>

</ul>

<p>When you've done everything, commit to your repo and remember to
push back to origin. You should be able to see your edits in the web
interface. Before you consider the assignment "complete", I would
recommend that you verify everything above works by performing a clean
clone of your repo and run the public check scripts.</p>

<p>That's it!</p>

<h4 style="padding-top: 10px">Grading</h4>

<p>This assignment is worth a total of 50 points, broken down as
follows:</p>

<ul>

  <li>Implementation correctness is worth 30 points. Note that the
  questions above are not explicitly worth any points; they exist
  primarily to help us gauge your implementation correctness. For
  example, if your index size is larger than we expect, it's likely
  you've not applied compression correctly. If your retrieved results
  do not match ours, it's likely you have a bug in your retrieval
  implementation.</li>

  <li>Getting your code to compile and successfully run is worth
  another 10 points (5 points for the Linux student CS environment and
  5 points on the Altiscale cluster). We will make a minimal effort to
  fix <i>trivial</i> issues with your code (e.g., a typo)&mdash;and
  deduct points&mdash;but <b>will not</b> spend time debugging your
  code. It is your responsibility to make sure your code runs: we have
  taken care to specify exactly how we will run your code&mdash;if
  anything is unclear, it is your responsibility to seek
  clarification.   In
  order to get a perfect score of 10 for this portion of the grade, we
  should be able to run the two public check
  scripts: <a href="assignments/check_assignment3_public_linux.py"><code>check_assignment3_public_linux.py</code></a>
  (on Linux Student CS)
  an <a href="assignments/check_assignment3_public_altiscale.py"><code>check_assignment3_public_altiscale.py</code></a>
  (on Altiscale cluster) successfully without any errors.</li>

  <li>Another 10 points is allotted to us verifying the behavior and
  output of your program in ways that we will not tell you. We're
  giving you the "public" versions of the check scripts; we'll run a
  "private" version to examine your output further (i.e., think blind
  test cases).</li>

</ul>

<p style="padding-top: 20px"><a href="#">Back to top</a></p>
</div>
</section>


<section id="assignment4" style="padding-top:35px">
<div>
<h3>Assignment 4: Multi-Source Personalized PageRank <small>due 8:30am February 9</small></h3>

<p>For this assignment, you will be working in the same repo as
before, except that everything should go into the package namespace
<code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment4</code>
(obviously, replace <code>lintool</code> with your actual GitHub
username.</p>

<p>Begin by taking the time to understand
the <a href="https://github.com/lintool/bespin/tree/master/src/main/java/io/bespin/java/mapreduce/pagerank">PageRank
reference implementation</a> in <a href="http://bespin.io">Bespin</a>
(particularly <code>RunPageRankBasic</code>).  For this assignment,
you are going to implement multiple-source personalized PageRank. As
we discussed in class, personalized PageRank is different from
ordinary PageRank in a few respects:</p>

<ul>

  <li>There is the notion of a <i>source</i> node, which is what we're
  computing the personalization with respect to.</li>

  <li>When initializing PageRank, instead of a uniform distribution
  across all nodes, the source node gets a mass of one and every other
  node gets a mass of zero.</li>

  <li>Whenever the model makes a random jump, the random jump is
  always back to the source node; this is unlike in ordinary PageRank,
  where there is an equal probability of jumping to any node.</li>

  <li>All mass lost in the dangling nodes are put back into the source
  node; this is unlike in ordinary PageRank, where the missing mass is
  evenly distributed across all nodes.</li>

</ul>

<p>Here are some publications about personalized PageRank if you're
interested. They're just provided for background; neither is necessary
for completing the assignment.</p>

<ul>

  <li>Daniel Fogaras, Balazs Racz, Karoly Csalogany, and Tamas Sarlos. (2005) <a href="assignments/Fogaras_etal_2005.pdf">Towards Scaling Fully Personalized PageRank: Algorithms, Lower Bounds, and Experiments.</a> Internet Mathematics, 2(3):333-358.</li>

  <li>Bahman Bahmani, Abdur Chowdhury, and Ashish Goel. (2010) <a href="assignments/Bahmani_etal_VLDB2010.pdf">Fast Incremental and Personalized PageRank.</a> Proceedings of the 36th International Conference on Very Large Data Bases (VLDB 2010).</li>


</ul>

<p>Your implementation is going to run multiple personalized PageRank
computations in parallel, one with respect to each source. The sources
will be specified on the command line. This means that each
PageRank node object (i.e., <code>Writable</code>) is going to contain
an array of PageRank values.</p>

<p>Here's how the implementation is going to work: it largely follows
the reference implementation of <code>RunPageRankBasic</code>. You
must make your implementation work with respect to the command-line
invocations specified below.</p>

<p>First, convert the adjacency list into PageRank node records:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment4.BuildPersonalizedPageRankRecords \
   -input data/p2p-Gnutella08-adj.txt -output cs489-2016w-lintool-a4-Gnutella-PageRankRecords \
   -numNodes 6301 -sources 367,249,145
</pre>

<p>The <code>-sources</code> option specifies the source nodes for the
personalized PageRank computations. In this case, we're running three
computations in parallel, with respect to node ids 367, 249, and
145. You can expect the option value to be in the form of a
comma-separated list, and that all node ids actually exist in the
graph. The list of source nodes may be arbitrarily long, but for
practical purposes we won't test your code with more than a few.</p>

<p>Since we're running three personalized PageRank computations in
parallel, each PageRank node is going to hold an array of three
values, the personalized PageRank values with respect to the first
source, second source, and third source. You can expect the array
positions to correspond exactly to the position of the node id in the
source string.</p>

<p>Next, partition the graph (hash partitioning) and get ready to
iterate:</p>

<pre>
$ hadoop fs -mkdir cs489-2016w-lintool-a4-Gnutella-PageRank

$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment4.PartitionGraph \
   -input cs489-2016w-lintool-a4-Gnutella-PageRankRecords \
   -output cs489-2016w-lintool-a4-Gnutella-PageRank/iter0000 -numPartitions 5 -numNodes 6301
</pre>

<p>After setting everything up, iterate multi-source personalized
PageRank:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment4.RunPersonalizedPageRankBasic \
   -base cs489-2016w-lintool-a4-Gnutella-PageRank -numNodes 6301 -start 0 -end 20 -sources 367,249,145
</pre>

<p>Note that the sources are passed in from the command-line
again. Here, we're running twenty iterations.</p>

<p>Finally, run a program to extract the top ten personalized PageRank
values, with respect to each source.</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment4.ExtractTopPersonalizedPageRankNodes \
   -input cs489-2016w-lintool-a4-Gnutella-PageRank/iter0020 -output cs489-2016w-lintool-a4-Gnutella-PageRank-top10 \
   -top 10 -sources 367,249,145
</pre>

<p>The above program should print the following answer to stdout:</p>

<pre>
Source: 367
0.35257 367
0.04181 264
0.03889 266
0.03888 559
0.03883 5
0.03860 1317
0.03824 666
0.03817 7
0.03799 4
0.00850 249

Source: 249
0.34089 249
0.04034 251
0.03721 762
0.03688 123
0.03686 250
0.03668 753
0.03627 755
0.03623 351
0.03622 983
0.00949 367

Source: 145
0.36937 145
0.04195 1317
0.04120 265
0.03847 390
0.03606 367
0.03566 246
0.03525 667
0.03519 717
0.03513 149
0.03496 2098
</pre>

<h4 style="padding-top: 10px">Additional Specifications</h4>

<p>To make the final output easier to read, in the
class <code>ExtractTopPersonalizedPageRankNodes</code>, use the
following format to print each (personalized PageRank value, node id)
pair:</p>

<pre>
String.format("%.5f %d", pagerank, nodeid)
</pre>

<p>This will generate the final results in the same format as
above. Also note: print actual probabilities, not log
probabilities&mdash;although during the actual PageRank computation
keep values as log probabilities.</p>

<p>The final class <code>ExtractTopPersonalizedPageRankNodes</code>
does not need to be a MapReduce job (but it does need to read from
HDFS). Obviously, the other classes need to run MapReduce jobs.</p>

<p>The reference implementation of PageRank in Bespin has many
options: you can either use in-mapper combining or ordinary
combiners. In your implementation, use ordinary combiners.
Also, the reference implementation has
an option to either use range partitioning or hash partitioning: you
only need to implement hash partitioning. You can start with the
reference implementation and remove code that you don't need (see #2
below).</p>

<h4 style="padding-top: 10px">Hints and Suggestion</h4>

<p>To help you out, there's a small helper program in Bespin that
computes personalized PageRank using a sequential algorithm. Use it to
check your answers:</p>

<pre>
$ hadoop jar target/bespin-0.1.0-SNAPSHOT.jar io.bespin.java.mapreduce.pagerank.SequentialPersonalizedPageRank \
   -input data/p2p-Gnutella08-adj.txt -source 367
</pre>

<p>Note that this isn't actually a MapReduce job; we're simply using
Hadoop to run the <code>main</code> for convenience. The values from
your implementation should be pretty close to the output of the above
program, but might differ a bit due to convergence issues. After 20
iterations, the output of the MapReduce implementation should match to
at least the fourth decimal place.</p>

<p>This is complex assignment. I would suggest breaking the
implementation into the following steps:</p>

<ol>

<li>First, copy the reference PageRank implementation into your own
assignments repo (renaming the classes appropriately). Make sure you
can get it to run and output the correct results with ordinary
PageRank.</li>

<li>Simplify the code; i.e., if you decide to use the in-mapper
combiner, remove the code that works with ordinary combiners.</li>

<li>Implement personalized PageRank from a single source; that is, if
the user sets option <code>-sources w,x,y,z</code>, simply
ignore <code>x,y,z</code> and run personalized PageRank with respect
to <code>w</code>. This can be accomplished with the
existing <code>PageRankNode</code>, which holds a single floating
point value.</li>

<li>Extend the <code>PageRankNode</code> class to store an array of
floats (length of array is the number of sources) instead of a single
float. Make sure single-source personalized PageRank still runs.</li>

<li>Implement multi-source personalized PageRank.</li>

</ol>

<p>In particular, #3 is a nice checkpoint. If you're not able to get
the multiple-source personalized PageRank to work, at least completing
the single-source implementation will allow us to give you partial
credit.</p>

<h4 style="padding-top: 10px">Running on the Altiscale cluster</h4>

<p>Once you get your implementation working and debugged in the Linux
environment, you're going to run your code on a non-trivial graph: the
link structure of (all of) Wikipedia. The adjacency lists are stored
in <code>/shared/cs489/data/wiki-adj</code> on HDFS. The graph has
16,117,779 vertices and 155,472,640 edges.</p>

<p>First, convert the adjacency list into PageRank node records:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment4.BuildPersonalizedPageRankRecords \
   -input /shared/cs489/data/wiki-adj -output cs489-2016w-lintool-a4-wiki-PageRankRecords \
   -numNodes 16117779 -sources 73273,73276
</pre>

<p>Next, partition the graph (hash partitioning) and get ready to
iterate:</p>

<pre>
$ hadoop fs -mkdir cs489-2016w-lintool-a4-wiki-PageRank

$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment4.PartitionGraph \
   -input cs489-2016w-lintool-a4-wiki-PageRankRecords \
   -output cs489-2016w-lintool-a4-wiki-PageRank/iter0000 -numPartitions 10 -numNodes 16117779
</pre>

<p>After setting everything up, iterate multi-source
personalized PageRank:</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment4.RunPersonalizedPageRankBasic \
   -base cs489-2016w-lintool-a4-wiki-PageRank -numNodes 16117779 -start 0 -end 20 -sources 73273,73276
</pre>

<p>On the Altiscale cluster, each iteration shouldn't take more than a
couple of minutes to complete. If it's taking more than five minutes
per iteration, you're doing something wrong.</p>

<p>Finally, run a program to extract the top ten personalized PageRank
values, with respect to each source.</p>

<pre>
$ hadoop jar target/bigdata2016w-0.1.0-SNAPSHOT.jar \
   ca.uwaterloo.cs.bigdata2016w.lintool.assignment4.ExtractTopPersonalizedPageRankNodes \
   -input cs489-2016w-lintool-a4-wiki-PageRank/iter0020 -output cs489-2016w-lintool-a4-wiki-PageRank-top10 \
   -top 10 -sources 73273,73276
</pre>

<p>In the example above, we're running personalized PageRank with
respect to two sources: 73273 and 73276. What articles do these ids
correspond to? There's a file on HDFS
at <code>/shared/cs489/data/wiki-titles.txt</code> that provides the
answer. How do you know if your implementation is correct? You can
sanity check your results by taking the ids and looking up the
articles that they correspond to. Do the results make sense?</p>

<h4 style="padding-top: 10px">Turning in the Assignment</h4>

<p>Please follow these instructions carefully!</p>

<p>Make sure your repo has the following items:</p>

<ul>

<li>Similar to the previous assignments, you'll create a file
called <code>bigdata2016w/assignment4.md</code> (more below).</li>

<li>All the implementations described above should be in
package <code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment4</code>.</li>

</ul>

<p>Make sure your implementation runs in the Linux student CS
environment on the Gnutella graph and on the Wikipedia graph on the
Altiscale cluster.</p>

<p>In <code>bigdata2016w/assignment4.md</code>, tell us if you were
able to successfully complete the assignment. This is in case we can't
get your code to run, we need to know if it is because you weren't able
to complete the assignment successfully, or if it is due to some other
issue. If you were not able to implement everything, describe how far
you've gotten. Feel free to use this space to tell us additional
things we should look for in your implementation.</p>

<p>Also, in this file, copy the output of your implementation on the
Altiscale cluster, i.e., personalized PageRank with respect to
vertices 73273 and 73276. This will give us something to look at and
check if we can't get your code to run successfully. Something that
looks like this:</p>

<pre>
Source: 73273
0.XXXXX XXX
...

Source: 73276
0.XXXXX XXX
...
</pre>

<p>When grading, we will clone your repo and use the below check
scripts:</p>

<ul>

<li><a href="assignments/check_assignment4_public_linux.py"><code>check_assignment4_public_linux.py</code></a>
in the Linux Student CS environment.</li>

<li><a href="assignments/check_assignment4_public_altiscale.py"><code>check_assignment4_public_altiscale.py</code></a>
on the Altiscale cluster.</li>

</ul>

<p>When you've done everything, commit to your repo and remember to
push back to origin. You should be able to see your edits in the web
interface. Before you consider the assignment "complete", I would
recommend that you verify everything above works by performing a clean
clone of your repo and run the public check scripts.</p>

<p>That's it!</p>

<h4 style="padding-top: 10px">Grading</h4>

<p>The entire assignment is worth 55 points:

<ul>

<li>A correct implementation of single-source personalized PageRank is
worth 10 points.</li>

<li>That we are able to run the single-source personalized PageRank
implementation in the Linux Student CS environment is worth 5
points.</li>

<li>A correct implementation of multiple-source personalized PageRank
is worth 15 points.</li>

<li>That we are able to run the multiple-source personalized PageRank
implementation in the Linux Student CS environment is worth 5
points.</li>

<li>Scaling the single-source personalized PageRank implementation on
Altiscale is worth 10 points.</li>

<li>Scaling the multiple-source personalized PageRank implementation
on Altiscale is worth 10 points.</li>

</ul>

<p>In our private check scripts, we will specify arbitrary source
nodes to verify the correctness of your implementation.</p>

<p>Note that this grading scheme discretizes each component of the
assignment. For example, if you implement everything and it works
correctly on the Linux Student CS environment, but can't get it to
scale on the Altiscale cluster to the larger graph, you'll receive 35
out of 55 points. On the other hand, if you implement single-source
personalized PageRank correctly and it runs in both the Linux Student
CS environment and Altiscale, you will receive 25 out of 55
points. And combinations thereof.</p>

<p style="padding-top: 20px"><a href="#">Back to top</a></p>
</div>
</section>


<section id="assignment5" style="padding-top:35px">
<div>
<h3>Assignment 5: Data Warehousing <small>due 8:30am March 3</small></h3>

<p><b>Warning:</b> This assignment is not completely written yet. It
is provided in draft form for those who wish to get a head start on
the assignment. The assignment will not be considered "complete" until
this message is removed. If you start working on the problems, it is
your responsibility to make sure that your solutions actually match
the final questions.</p>

<p>In this assignment you'll be hand-crafting Spark programs that
implement SQL queries in a data warehousing scenario. Various
SQL-on-Hadoop solutions share in providing an SQL query interface on
data stored in HDFS via an intermediate execution framework. For
example, Hive queries are "compiled" into MapReduce jobs; SparkSQL
queries rely on Spark processing primitives for query execution. In
this assignment, you'll play the role of mediating between SQL queries
and the underlying execution framework (Spark). In more detail, you'll
be given a series of SQL queries, and for each you'll have to
hand-craft a Spark program that corresponds to each query.</p>

<p><b>Important:</b> You are not allowed to use <code>join</code> and
closely-related transformations in Spark for this assignment, because
otherwise it defeats the point of the exercise. The assignment will
guide you toward what we are looking for, but if you have any
questions as to what is allowed or not, ask!</p>

<p>We will be working with data from the TPC-H benchmark in this
assignment. The Transaction Processing Performance Council (TPC) is a
non-profit organization that defines various database benchmarks so
that database vendors can evaluate the performance of their products
fairly. TPC defines the "rules of the game", so to speak. TPC defines
various benchmarks, of which one is TPC-H, for evaluating ad-hoc
decision support systems in a data warehousing scenario. The current
version of the TPC-H benchmark is located
<a href="assignments/tpc-h_v2.17.1.pdf">here</a>. You'll want to skim
through this (long) document; the most important part is the
entity-relationship diagram of the data warehouse on page
13. Throughout the assignment you'll likely be referring to it, as it
will help you make sense of the queries you are running.</p>

<p>The TPC-H benchmark comes with a data generator, and we have
generated some data for
you <a href="assignments/TPC-H-0.1-TXT.tar.gz">here</a>
(<code>TPC-H-0.1-TXT.tar.gz</code>). For the first
part of the assignment where you will be working with Spark locally,
you will run your queries against this data.
Download and unpack the data above: you will see a number of text files,
each corresponding to a table in the TPC-H schema. The files are
delimited by <code>|</code>. You'll notice that some of the fields,
especially the text fields, are gibberish&mdash;that's normal, since
the data are randomly generated.</p>

<p>Implement the following seven SQL queries, running on
the <code>TPC-H-0.1-TXT</code> data. Each SQL query is
accompanied by a written description of what the query does; if there
are any ambiguities in the language, you can always assume that the
SQL query is correct. Each of your query will be a separate Spark
program. Put your code in the package
<code>ca.uwaterloo.cs.bigdata2016w.lintool.assignment5</code>, in the
same repo that you've been working in all semester. Since you'll be
writing Scala code, your source files should go into
<code>src/main/scala/ca/uwaterloo/cs/bigdata2016w/lintool/assignment5/</code>.
Obviously, replace <code>lintool</code> with your actual GitHub
username.</p>

<p><b>Q1:</b> How many items were shipped on a particular date? This corresponds to the following SQL query:

<pre>
select count(*) from lineitem where l_shipdate = 'YYYY-MM-DD';
</pre>

<p>Write a program such that when we execute the following
command:</p>

<pre>
spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment5.Q1 \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input TPC-H-0.1-TXT --date '1996-01-01'
</pre>

<p>the answer to the above SQL query will be printed to stdout, in a line
that matches the following regular expression:</p>

<pre>
ANSWER=\d+
</pre>

<p>The output of the query can contain logging and debug information,
but there must be a line with the answer in <b>exactly</b> the above
format.</p>

<p>The value of the
<code>--input</code> argument is the directory that contains the
plain-text tables. The value of the <code>--date</code> argument
corresponds to the <code>l_shipdate</code> predicate in the where
clause in the SQL query. You need to anticipate dates of the
form <code>YYYY-MM-DD</code>, <code>YYYY-MM</code>, or
just <code>YYYY</code>, and your query needs to give the correct
answer depending on the date format. You can assume that a valid date
(in one of the above formats) is provided, so you do not need to
perform input validation.</p>

<p><b>Q2:</b> Which clerks were responsible for processing items that
were shipped on a particular date? List the first 20 by order
key. This corresponds to the following SQL query:</p>

<pre>
select o_clerk, o_orderkey from lineitem, orders
where
  l_orderkey = o_orderkey and
  l_shipdate = 'YYYY-MM-DD'
order by o_orderkey asc limit 20;
</pre>

<p>Write a program such that when we execute the following
command:</p>

<pre>
spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment5.Q2 \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input TPC-H-0.1-TXT --date '1996-01-01'
</pre>

<p>the answer to the above SQL query will be printed to stdout, as a
sequence of tuples in the following format:</p>

<pre>
(o_clerk,o_orderkey)
(o_clerk,o_orderkey)
...
</pre>

<p>That is, each tuple is comma-delimited and surrounded by
parentheses. Everything described in <b>Q1</b> about dates applies
here as well.</p>

<p>In the design of this data warehouse, the <code>lineitem</code>
and <code>orders</code> tables are not likely to fit in
memory. Therefore, the only scalable join approach is the reduce-side
join. You must implement this join in Spark using
the <code>cogroup</code> transformation.</p>

<p><b>Q3:</b> What are the names of parts and suppliers of items
shipped on a particular date? List the first 20 by order key. This
corresponds to the following SQL query:</p>

<pre>
select l_orderkey, p_name, s_name from lineitem, part, supplier
where
  l_partkey = p_partkey and
  l_suppkey = s_suppkey and
  l_shipdate = 'YYYY-MM-DD'
order by l_orderkey asc limit 20;
</pre>

<p>Write a program such that when we execute the following
command:</p>

<pre>
spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment5.Q3 \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input TPC-H-0.1-TXT --date '1996-01-01'
</pre>

<p>the answer to the above SQL query will be printed to stdout, as a
sequence of tuples in the following format:</p>

<pre>
(l_orderkey,p_name,s_name)
(l_orderkey,p_name,s_name)
...
</pre>

<p>That is, each tuple is comma-delimited and surrounded by
parentheses. Everything described in <b>Q1</b> about dates applies
here as well.</p>

<p>In the design of this data warehouse, it is assumed that
the <code>part</code> and <code>supplier</code> tables will fit in
memory. Therefore, it is possible to implement a hash join. For this
query, you must implement a hash join in Spark with broadcast
variables.</p>

<p><b>Q4:</b> How many items were shipped to each country on a
particular date? This corresponds to the following SQL query:</p>

<pre>
select n_nationkey, n_name, count(*) from lineitem, orders, customer, nation
where
  l_orderkey = o_orderkey and
  o_custkey = c_custkey and
  c_nationkey = n_nationkey and
  l_shipdate = 'YYYY-MM-DD'
group by n_nationkey, n_name
order by n_nationkey asc;
</pre>

<p>Write a program such that when we execute the following
command:</p>

<pre>
spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment5.Q4 \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input TPC-H-0.1-TXT --date '1996-01-01'
</pre>

<p>the answer to the above SQL query will be printed to stdout. Format
the output in the same manner as with the above queries: one tuple per
line, where each tuple is comma-delimited and surrounded by
parentheses. Everything described in <b>Q1</b> about dates applies
here as well.</p>

<p>Implement this query with different join techniques as you see
fit. You can assume that the <code>lineitem</code>
and <code>orders</code> table will not fit in memory, but you can
assume that the <code>customer</code> and <code>nation</code> tables
will both fit in memory. For this query, the performance as well as
the scalability of your implementation will contribute to the
grade.</p>

<p><b>Q5:</b> This query represents a very simple end-to-end ad hoc
analysis task: Related to <b>Q4</b>, your boss has asked you to
compare shipments to Canada vs. the United States by day, given all
the data in the data warehouse. You think this request is best
fulfilled by a line graph, with two lines (one representing the US and
one representing Canada), where the <i>x</i>-axis is the date and
the <i>y</i> axis is the volume. Generate this graph for your
boss.</p>

<p>First, write a program such that when we execute the following
command:</p>

<pre>
spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment5.Q5 \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input TPC-H-0.1-TXT
</pre>

<p>the raw data necessary for the graph will be printed to stdout.
Format the output in the same manner as with the above queries: one
tuple per line, where each tuple is comma-delimited and surrounded by
parentheses.</p>

<p>Next, create this actual graph: use whatever tool you are
comfortable with, e.g., Excel, gnuplot, etc.</p>

<p><b>Q6:</b> This is a slightly modified version of TPC-H Q1 "Pricing
Summary Report Query". This query reports the amount of business that
was billed, shipped, and returned:</p>

<pre>
select
  l_returnflag,
  l_linestatus,
  sum(l_quantity) as sum_qty,
  sum(l_extendedprice) as sum_base_price,
  sum(l_extendedprice*(1-l_discount)) as sum_disc_price,
  sum(l_extendedprice*(1-l_discount)*(1+l_tax)) as sum_charge,
  avg(l_quantity) as avg_qty,
  avg(l_extendedprice) as avg_price,
  avg(l_discount) as avg_disc,
  count(*) as count_order
from lineitem
where
  l_shipdate = 'YYYY-MM-DD'
group by l_returnflag, l_linestatus;
</pre>

<p>Write a program such that when we execute the following
command:</p>

<pre>
spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment5.Q6 \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input TPC-H-0.1-TXT --date '1996-01-01'
</pre>

<p>the answer to the above SQL query will be printed to stdout. Format
the output in the same manner as with the above queries: one tuple per
line, where each tuple is comma-delimited and surrounded by
parentheses. Everything described in <b>Q1</b> about dates applies
here as well.</p>

<p>Implement this query as efficiently as you can, using all of the
optimizations we discussed in lecture. You will only get full points
for this question if you exploit all the optimization opportunities
that are available.</p>

<p><b>Q7:</b> This is a slightly modified version of TPC-H Q3
"Shipping Priority Query".  This query retrieves the 10 unshipped
orders with the highest value:</p>

<pre>
select
  l_orderkey,
  sum(l_extendedprice*(1-l_discount)) as revenue,
  o_orderdate,
  o_shippriority
from customer, orders, lineitem
where
  c_custkey = o_custkey and
  l_orderkey = o_orderkey and
  o_orderdate < "YYYY-MM-DD" and
  l_shipdate > "YYYY-MM-DD"
group by
  l_orderkey,
  o_orderdate,
  o_shippriority
order by
  revenue desc
limit 10;
</pre>

<p>Write a program such that when we execute the following
command:</p>

<pre>
spark-submit --class ca.uwaterloo.cs.bigdata2016w.lintool.assignment5.Q7 \
   target/bigdata2016w-0.1.0-SNAPSHOT.jar --input TPC-H-0.1-TXT --date '1996-01-01'
</pre>

<p>the answer to the above SQL query will be printed to stdout.
Format the output in the same manner as with the above queries: one
tuple per line, where each tuple is comma-delimited and surrounded by
parentheses. Here you can assume that the date argument is only in the
format <code>YYYY-MM-DD</code> and that it is a valid date.</p>

<p>Implement this query as efficiently as you can, using all of the
optimizations we discussed in lecture. Plan you joins as you see fit,
keeping in mind above assumptions on what will and will not fit in
memory. You will only get full points for this question if you exploit
all the optimization opportunities that are available.</p>

<h4 style="padding-top: 10px">Scaling up on Altiscale</h4>

<p>TBA</p>

<h4 style="padding-top: 10px">Turning in the Assignment</h4>

<p>Please follow these instructions carefully!</p>

<p>TBA</p>

<h4 style="padding-top: 10px">Grading</h4>

<p>TBA</p>

<p style="padding-top: 20px"><a href="#">Back to top</a></p>
</div>
</section>


<section id="assignment6" style="padding-top:35px">
<div>
<h3>Assignment 6: Duplicate Sentence Detection <small>due 8:30am March 17</small></h3>

<p style="padding-top: 20px"><a href="#">Back to top</a></p>
</div>
</section>


<section id="assignment7" style="padding-top:35px">
<div>
<h3>Assignment 7: Inverted Indexing (Redux) <small>due 8:30am March 24</small></h3>

<p style="padding-top: 20px"><a href="#">Back to top</a></p>
</div>
</section>

<p style="padding-top:100px" />

    </div><!-- /.container -->


    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="js/bootstrap.min.js"></script>

    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="js/ie10-viewport-bug-workaround.js"></script>
  </body>

</html>
